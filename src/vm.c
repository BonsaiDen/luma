#include "../include/game.h"
#include "../include/vm.h"
#include "../include/vm.console.h"
#include "../include/io.h"

// Bootstrap code generated by make file
#include "../include/boot.lua.h"


// API ------------------------------------------------------------------------
// ----------------------------------------------------------------------------
int internal_handle_error(lua_State *L);

bool internal_require_file(const char *filename, const bool wasRequired);
bool internal_execute_script
(const char *buf, unsigned int len, const char *filename,  const bool wasRequired);

bool vm_init() {

    gLuaState = luaL_newstate();

    if (gLuaState != NULL) {

        // Load lua libraries
        luaopen_base(gLuaState);
        luaopen_string(gLuaState);
        luaopen_math(gLuaState);
        luaopen_debug(gLuaState);
        luaopen_bit32(gLuaState);

        // Override lua's builtin require function 
        lua_getglobal(gLuaState, "_G"); // +1
        lua_pushcfunction(gLuaState, luax_require); // +1
        lua_setfield(gLuaState, -2, "require"); // -1
        lua_pop(gLuaState, 1); // -1

        // Set the error handler at stack offset 1
        lua_pushcfunction(gLuaState, &internal_handle_error); // +1 = 1

        // Load bootstrap code
        internal_execute_script((char*)src_boot_lua, src_boot_lua_len, "<boot>", false);

        // Setup console
        vm_global_get("console");
        vm_field_set_function("log", console_log);
        vm_field_set_function("info", console_info);
        vm_field_set_function("warn", console_warn);
        vm_field_set_function("error", console_error);
        vm_rewind();

        assert(lua_gettop(gLuaState) == 1);

        vm_info("init success");
        return true;
        
    } else {
        vm_info("init failed to create lua state");
        return false;
    }

}

bool vm_require(const char *filename) {
    return internal_require_file(filename, false);
}

bool vm_update() {
    vm_info("update");
    return true;
}

bool vm_shutdown() {

    if (gLuaState != NULL) {
        vm_rewind();
        lua_close(gLuaState);
        vm_info("shutdown success");
        return true;
        
    } else {
        vm_info("shutdown failed");
        return false;
    }
    
}

void vm_api() {


}


// Abstractions ---------------------------------------------------------------
// ----------------------------------------------------------------------------
void vm_rewind() {
    const int count = lua_gettop(gLuaState) - 1;
    if (count > 0) {
        vm_info("dropping %d stack entries", count);
        lua_pop(gLuaState, count);
    }
    assert(lua_gettop(gLuaState) == 1);
}

void vm_global_set(const char *name) {
    lua_setglobal(gLuaState, name);
}

void vm_global_get(const char *name) {
    lua_getglobal(gLuaState, name);
}

void vm_object_create() {
    lua_newtable(gLuaState);
}

void vm_field_get(const char *field) {
    lua_getfield(gLuaState, -1, field);
}

void vm_field_set(const char *field) {
    lua_setfield(gLuaState, -2, field);
}

void vm_field_set_nil(const char *field) {
    lua_pushnil(gLuaState);
    lua_setfield(gLuaState, -2, field);
}

void vm_field_set_function(const char *field, void *func) {
    lua_pushcfunction(gLuaState, func);
    lua_setfield(gLuaState, -2, field);
}

void vm_field_set_string(const char *field, const char *string) {
    lua_pushstring(gLuaState, string);
    lua_setfield(gLuaState, -2, field);
}

const char *vm_field_get_string(const char *field) {

    unsigned int length = 0;
    const char *string;

    lua_getfield(gLuaState, -1, field);
    string = lua_tolstring(gLuaState, -1, &length);
    lua_pop(gLuaState, 1);

    return string;

}

void vm_field_set_integer(const char *field, const int i) {
    lua_pushinteger(gLuaState, i);
    lua_setfield(gLuaState, -2, field);
}

int vm_field_get_integer(const char *field) {

    int i = 0;

    lua_getfield(gLuaState, -1, field);
    i = lua_tointeger(gLuaState, -1);
    lua_pop(gLuaState, 1);

    return i;

}

void vm_field_set_double(const char *field, const double d) {
    lua_pushnumber(gLuaState, d);
    lua_setfield(gLuaState, -2, field);
}

double vm_field_get_double(const char *field) {
    
    double d = 0;

    lua_getfield(gLuaState, -1, field);
    d = lua_tonumber(gLuaState, -1);
    lua_pop(gLuaState, 1);

    return d;

}


// Internal -------------------------------------------------------------------
// ----------------------------------------------------------------------------
int internal_handle_error(lua_State *L) {
    
    const char *err = lua_tostring(L, -1); // = 1
    lua_getglobal(L, "debug"); // +1
    lua_getfield(L, -1, "traceback"); // +1
    lua_remove(L, -2); // - 1
    lua_call(L, 0, 1); // +1
    vm_error("%s\n - %s\n", lua_tostring(L, -1), err);
    lua_pop(L, 1); // -1 = 1

    return 0;

}

bool internal_execute_script
(const char *buf, unsigned int len, const char *filename, const bool wasRequired) {

    luaL_loadbuffer(gLuaState, buf, len, filename); 
    if (lua_pcall(gLuaState, 0, 1, 0) != 0) { // +1 if no error (?)
        vm_error("script '%s' failed", filename);
        internal_handle_error(gLuaState);
        return false;

    } else {

        vm_info("script '%s' executed", filename);
        if (!wasRequired) {
            lua_pop(gLuaState, 1); // -1
        }

        return true;

    }

}

bool internal_require_file(const char *filename, const bool wasRequired) {

    char *buf;
    unsigned int len;
    bool success = false;
    buf = io_load_resource(filename, &len);

    if (buf == NULL) {
        vm_error("script '%s' not found", filename);

    } else {
        vm_info("script '%s' loaded", filename);
        success = internal_execute_script(buf, len, filename, wasRequired);
        free(buf);
    }

    return success;

}


// Extensions -----------------------------------------------------------------
// ----------------------------------------------------------------------------
int luax_require(lua_State *L) {

    const char *filename = luaL_checkstring(L, 1);
    char *str = (char*)calloc(strlen(filename) + 5, sizeof(char));
    strcat(str, filename);
    strcat(str, ".lua");
    internal_require_file(str, true);
    free(str);
    return 1;

}

bool luax_optboolean(lua_State * L, const int idx, const bool b) {

    if (lua_isboolean(L, idx) == 1) {
        return (lua_toboolean(L, idx) == 1 ? true : false);

    } else {
        return b;
    }

}

