#include "../include/game.h"
#include "../include/io.h"
#include "../include/vm.h"
#include "../include/vm.console.h"
#include "../include/vm.extend.h"

// Bootstrap code generated by make file
#include "../include/boot.lua.h"


// API ------------------------------------------------------------------------
// ----------------------------------------------------------------------------
static const luaL_Reg loadedlibs[] = {
  {"_G", luaopen_base},
  {LUA_TABLIBNAME, luaopen_table},
  {LUA_STRLIBNAME, luaopen_string},
  {LUA_BITLIBNAME, luaopen_bit32},
  {LUA_MATHLIBNAME, luaopen_math},
  {LUA_DBLIBNAME, luaopen_debug},
  {NULL, NULL}
};

static int errorHandlerStackIndex = 0;
static int internal_handle_error(lua_State *L);

static bool internal_require_file(const char *filename, const bool wasRequired);
static bool internal_execute_script(const char *buf, unsigned int len, 
                                    const char *filename,  const bool wasRequired);

int test(lua_State *L) {
    void *ptr = lua_newuserdata(L, sizeof(char) * 32);
    vm_object_create();
    vm_field_set_string("name", "Test");
    lua_setmetatable(L, 1);
    return 1;
}

bool vm_init() {

    gLuaState = luaL_newstate();

    if (gLuaState != NULL) {

        // Load lua libraries
        const luaL_Reg *lib;
        for (lib = loadedlibs; lib->func; lib++) {
            luaL_requiref(gLuaState, lib->name, lib->func, 1);
            lua_pop(gLuaState, 1);  /* remove lib */
        }

        // Override lua's builtin require function 
        lua_getglobal(gLuaState, "_G"); 
        lua_pushcfunction(gLuaState, luax_require); 
        lua_setfield(gLuaState, -2, "require"); 
        vm_rewind();

        // Set the error handler at stack offset 1
        lua_pushcfunction(gLuaState, internal_handle_error); 
        errorHandlerStackIndex = lua_gettop(gLuaState);

        // Load bootstrap code
        internal_execute_script((char*)src_boot_lua, src_boot_lua_len, "<boot>", false);

        // Setup console
        vm_global_get("console");
        vm_field_set_function("log", console_log);
        vm_field_set_function("info", console_info);
        vm_field_set_function("warn", console_warn);
        vm_field_set_function("error", console_error);

        vm_global_get("game");
        vm_field_set_function("test", test);
        vm_rewind();

        assert(lua_gettop(gLuaState) == 1);

        vm_info("init success");
        return true;
        
    } else {
        vm_info("init failed to create lua state");
        return false;
    }

}

bool vm_require(const char *filename) {
    return internal_require_file(filename, false);
}

bool vm_update() {
    vm_info("update");
    return true;
}

bool vm_shutdown() {

    if (gLuaState != NULL) {
        vm_rewind();
        lua_close(gLuaState);
        vm_info("shutdown success");
        return true;
        
    } else {
        vm_info("shutdown failed");
        return false;
    }
    
}

void vm_rewind() {
    const int count = lua_gettop(gLuaState) - errorHandlerStackIndex;
    if (count > 0) {
        vm_info("dropping %d stack entries", count);
        lua_pop(gLuaState, count);
    }
    assert(lua_gettop(gLuaState) == errorHandlerStackIndex);
}


// Internal -------------------------------------------------------------------
// ----------------------------------------------------------------------------
static int internal_handle_error(lua_State *L) {
    
    const char *err = lua_tostring(L, -1); // = 1
    lua_State *s = luaL_newstate();
    luaL_traceback(s, L, NULL, 1);
    vm_error("%s\n%s", err, lua_tostring(s, -1));
    lua_close(s);
    return 0;

}

static bool internal_execute_script(const char *buf, unsigned int len, 
                                    const char *filename, const bool wasRequired) {

    luaL_loadbuffer(gLuaState, buf, len, filename); 
    if (lua_pcall(gLuaState, 0, 1, errorHandlerStackIndex) != LUA_OK) { 
        vm_rewind();
        return false;

    } else {

        vm_info("script '%s' executed", filename);
        if (!wasRequired) {
            lua_pop(gLuaState, 1); // -1
        }

        return true;

    }

}

static bool internal_require_file(const char *filename, const bool wasRequired) {

    IOResource *text;
    text = io_load_text(filename);

    if (text == NULL) {
        vm_error("script '%s' not found", filename);
        return false;

    } else {
        vm_info("script '%s' loaded", filename);
        return internal_execute_script(text->handle, text->size, text->filename, wasRequired);
    }

}


// Extensions -----------------------------------------------------------------
// ----------------------------------------------------------------------------
int luax_require(lua_State *L) {

    const char *filename = luaL_checkstring(L, 1);
    char *str = (char*)calloc(strlen(filename) + 5, sizeof(char));
    strcat(str, filename);
    strcat(str, ".lua");
    internal_require_file(str, true);
    free(str);
    return 1;

}

bool luax_optboolean(lua_State * L, const int idx, const bool b) {

    if (lua_isboolean(L, idx) == 1) {
        return (lua_toboolean(L, idx) == 1 ? true : false);

    } else {
        return b;
    }

}

